\documentclass[a4paper,12pt]{report}

\input{packages} %Подключаем модуль пакетов
\input{styles} %Подключаем модуль стилей

\begin{document}

\input{names} %Подключаем модуль переименования некоторых команд

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % Титульная страница % % % % % % % % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}

\begin{center}
\MakeUppercase{МФТИ ФИВТ} \par
\MakeUppercase{Московский физико-технический институт (государственный университет), факультет инноваций и высоких технологий} \par 
\par
\end{center}

\vspace{50mm}

\begin{center}
{\large Луничкин Егор Валериевич}
\end{center}

\vspace{5mm}
\begin{center}
{\bf \large \MakeUppercase{Теорема Блума об ускорениях}
\par}

\vspace{20mm}

\end{center}

\vspace{100mm}


\begin{center}
{Долгопрудный -- 2015}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % Содержание % % % % % % % % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % Глава 1 % % % % % % % % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Введение}
\section{Аннотация}
Теорема Блума об ускорениях~--- это одна из базовых теорем в теории сложности. В этой работе изложено одно из упрощённых доказательств этой теоремы, которое, однако, хорошо обобщается на весь класс общерекурсивных (а следовательно, и частично рекурсивных) функций. 
\section{Обозначения}
В этой статье используется нотация, аналогичная \cite{Rogers}. $\lambda i \phi_i$~--- стандартная индексация частично рекурсивных функций. $\mathbb{N}$~--- множество всех неотрицательных целых. $\lambda i D_i$~--- все конечные подмножества $\mathbb{N}$. Аналогично, $\lambda i F_i$~--- индексация всех финитных функций, определённых на участке $\{0, 1, 2, \dots , n\}$. $\lambda_i \Phi_i$~--- любая мера вычислительной или ресурсной сложности задачи по Блуму. В частности, для всех $i$, область определения $\Phi_i$ в точности совпадает с областью определения $\phi_i$, и отношение $\Phi_i \leqq y$ рекурсивно разрешимо. Простым языком, $\Phi_i (x)$~--- количество времени или памяти, которое потребуется машине Тьюринга $i$ на входе $x$. Если $f$~--- некоторая функция, а  $S$~--- множество, то  $f/S$~--- ограничение $f$ на $S$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % Глава 2 % % % % % % % % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Теорема и её доказательство}

Доказательство, которое здесь будет приведено, является по своей сути упрощением доказательства Блума из \cite{Blum}. Хорошо известно, что для всех мер, связанных рекурсивно \cite{Blum}, следует, что если доказательство можно провести для одной из них, то оно будет верно для всех остальных, поэтому не будем проводить доказательство в самом общем случае. Начнём с того предположения, что для любой меры верно:

\begin{equation} \label{eq:2.1}
\Phi_{S(i,x)} (y) \leqq \Phi_i (x,y)
\end{equation}
и если $x\notin$ области определения $F_v$, 
\begin{equation} \label{eq:2.2}
\Phi_{\rho (i,v)} (x)\leqq \Phi_i (x) 
\end{equation}

Например, лента машины Тьюринга удовлетворяет этим условиям. Также предположим, что можно определить функцию рекурсивно не только по её предыдущим значениям, но и по предыдущим запускам. Это можно понять из следующего рассуждения: если мы использовали программу для вычисления значения функции на каком-либо начальном аргументе, мы можем узнать вычислительные ресурсы, которые потребовались для этого, даже не зная явно программу, которая вычисляет эту функцию. Теперь мы хотим доказать:

\section{Формулировка}

\textbf{Теорема} (Теорема Блума об ускорениях \cite{Blum}). \textit{Для каждой общерекурсивной функции $r(x,y)$ мы можем найти общерекурсивную функцию $f(x)$ такую, что из $\phi_i = f$ следует, что $\exists j$ такое, что $\phi_j = f$ и $\Phi_i (x) > r(x, \Phi_j (x))$ во всех точках кроме, быть может, конечного их числа.}

\section{Доказательство}

\subsection{Идея доказательства}

\underline{Доказательство.} Идея доказательства в том, чтобы построить функцию $\phi_t(u, x)$ такую, чтобы для любого $u$ было верно $\lambda x \phi_t (u, x) = \lambda x\phi_t(0, x)$. Положим $f=\lambda x \phi_t(0, x)$, и при построении будем использовать первый параметр $u$ в диагонализации по всем возможным программам, чтобы гарантировать, что если $\phi_i = f$, то $\Phi_i(x) \geqq r(x, \Phi_t(i+1, x))$ во всех точках, кроме, быть может, конечного их числа. В силу \eqref{eq:2.1} этого будет достаточно для доказательства теоремы. К сожалению, может быть доказано \cite{Blum}, что в общем случае невозможно сделать это, сохраняя $\lambda x \phi_t(u, x) = \lambda x\phi_t(0, x) \ \forall u$. Однако с учётом \eqref{eq:2.2} будет достаточно показать, что $\lambda x \phi_t(u, x) = \lambda x\phi_t (0, x)$ для всех точек, кроме конечного их числа и $\forall u$, так как всегда можно подправить $\lambda x \phi_t(u, x)$ на конечном числе входов, не увеличивая основной оценки сложности. Предлагается для начала доказать ослабленную версию \textbf{теоремы}:

\subsection{Лемма}

\textbf{Лемма} (Эффективные псевдоускорения; Блум \cite{Blum2}). \textit {Пусть $\Phi$~--- мера, удовлетворяющая \eqref{eq:2.1}. Тогда для каждой общерекурсивной функции $r(x,y)$ мы можем эффективно найти общерекурсивную функцию $f$, такую, что для любого данного $i$, для которого $\phi_i = f$, мы можем эффективно указать $j$, для которых $\phi_j = f$ и $\Phi_i(x) > r(x, \Phi_j(x))$ (для всех функций, кроме, быть может, конечного их числа).}

\underline{Доказательство.} Определим программу $t$, вычисляющую частную рекурсивную функцию двух переменных $\phi_t(u, x)$. Пусть $f = \lambda x \phi_t(0, x)$. Нужно показать, что $\phi_t$~--- общая. $\phi_t(u, x)$ задаётся рекурсивно через $\phi_t(u, 0), \phi_t(u, 1), \cdots , \phi_t(u, x-1)$, а также, если $u < x$, через $\phi_t(x, x), \phi_t(x-1, x), \phi_t(x-2, x), \cdots , \phi_t(u+1, x)$. Конкретно, на уровне $x$ зададим:

\begin{equation}
C_{u,x} = \left\{ i | u \leqq i < x \mbox{ и } i \notin \bigcup_{y<x} C_{u,v} \mbox{ и } \Phi_i(x) \leqq r(x, \phi_t(i+1, x)) \right\}
\end{equation}

Будем говорить, что $C_{u,x}$~--- это набор программ, \textit{отменённых} на этапе $x$ при вычислении $\phi_t(u, x)$. Тогда определим:

\begin{equation}
\phi_t(u,x) = 1 + \max\{\phi_i(x) | i \in C_{u,x}\}
\end{equation}

То есть, $\phi_i(x) = 1 + \max\{u \leqq i < x \mbox{ и } \Phi_i(x) \leqq r(x, \Phi_t(i+1, x))$, и $i$ не была отменена раньше при вычислении $\lambda x \phi_t(u, x)\}$.

Это прямо следует из определения, что $\phi_t(u,0) = 1$ для всех $u$ и $\phi_t(u, x) = 1$ всякий раз, когда $u \geqq x$. Более того, для любого $u < x$, для того, чтобы определить $\phi_t(u, x)$, необходимо определить $\Phi_t(x, x), \Phi_t(x-1, x), \Phi_t(x-2, x), \cdots , \Phi_t(u+1, x)$ и $\phi_t(u, 0), \phi_t(u, 1), \phi_t(u, 2), \cdots , \phi_t(u,x-1)$. Отсюда видно, что достаточно определить $\phi_t(x, x), \phi_t(x-1, x), \cdots , \phi_t(u+1, x) ; \phi_t(u, 0), \phi_t(u, 1), \cdots , \phi_t(u, x-1)$.

Продолжая по индукции, предположим, что $\lambda u \phi_t(u, x^{'})$~--- общая функция для всех $x^{'} < x$. Можно заметить, что $\phi_t(u, x) = 1$ для всех $u \geqq x$, значит, $\phi_t(x-1, x)$ определена. Аналогично, $\phi_t(x-2, x)$ определена. Продолжая рекурсивно до $\phi_t(0, x)$, увидим, что $\lambda u \phi_t(u, x)$~--- общая. Таким образом, по индукции доказано, что $\phi_t$~--- общая функция.

Очевидно, что $C_{0,x} - \{0, 1, \dots , u-1\} = C_{u,x}$. Более того, очевидно, что для каждого $u$ существует $n_u$, такой, что если $i < u$ и $i \in \bigcup_y C_{0,y}$, то

\begin{equation}
i \in \bigcup_{y \le n_u} C_{0,y}
\end{equation}

Таким образом, никакое $i < u$ не принадлежит $C_{0,x}$ для $x > n_u$. Отсюда сразу получаем, что для $x > n_u \ C_{0,x} = C_{u,x}$, а значит, $\phi_t(0, x) = \phi_t(u, x)$ для $x > n_u$.

Окончательно, если $\phi_i = \lambda x \phi(0, x)$, должно выполняться:

\begin{equation} \label{eq:2.6}
\phi_i(x) > r(x, \Phi_t(i+1, x)) \mbox{ для всех } x > i
\end{equation}

Иначе, при вычислении $\lambda x \phi_t(0,x)$, мы должны \textit{отменить} $i$ для первого такого $x > i$, приходя к противоречию $\phi_t(0,x) \ne \phi_i(x)$. Таким образом, доказательство фактически завершено.

Мы можем предположить без потери общности, что $r$ монотонна по своему второму аргументу. Тогда из \eqref{eq:2.6} и \eqref{eq:2.1} имеем:

\begin{equation} \label{eq:2.7}
\Phi_i(x) > r(x, \Phi_t(i+1, x)) \geqq r(x, \Phi_{S(t, i+1)}(x))
\end{equation}
для всех точек кроме, быть может, конечного числа.

Таким образом, мы завершили доказательство \textbf{леммы}.

\subsection{Завершение доказательства}

Так как для каждого $i$, $\lambda x \phi_t(0, x) = \phi_{\rho(S(t, i+1), v)}(x)$, то для некоторых $v$ в условиях, удовлетворяющих \eqref{eq:2.2}, из \eqref{eq:2.7} мы получаем:

\begin{equation} \label{eq:2.8}
\Phi_i(x) \geqq r(x, \Phi_{\rho(S(t, i+1), v)}(x)
\end{equation}
для всех точек кроме, быть может, конечного числа.

Таким образом, \textbf{теорема} доказана при данных условиях.

Как было отмечено ранее, доказательство \textbf{теоремы} при произвольных условиях не привязано к рекурсивному отношению, но прямое доказательство при произвольных условиях может быть получено изменением приведённого выше доказательства. Чтобы его провести, мы просто определим $\phi_t$ как приложение рекурсивной теоремы, изменяя определение $C_{u,x}$ на:

\begin{equation}
C_{u,x} = \left\{ i | u \leqq i < x \mbox{ и } i \notin \bigcup_{y < x} C_{u,y} \mbox{ и } \Phi_i(x) \leqq \max_{r<x} r(x, \Phi_{\rho(S(t, i+1), v)}(x) \right\}
\end{equation}

Теперь предыдущее доказательство повторяется практически дословно, исключая тот факт, что доказательство \eqref{eq:2.6} прямо переводится в доказательство желаемого, а именно \eqref{eq:2.8}.

На самом деле, \textbf{теорема об ускорениях} из \cite{Blum} немного сложнее, чем доказанная \textbf{теорема}, потому что в \cite{Blum} $f$ берётся как функция, принимающая значения $0-1$. Однако переход к случаю функции, принимающей любые значения, не является целью этой работы и не представляет большого интереса. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % Список литературы % % % % % % % % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{9}

\bibitem{Rogers}
Hartley Rogers, Jr., \textit{Theory of recursive functions and effective computability},
McGraw-Hill, New York, 1967. MR \textbf{37} \#61.

\bibitem{Blum}
M. Blum, \textit{A machine-independent theory of the complexity of recursive functions},
J. Assoc. Comput. Mach. \textbf{14} (1967), 322---336. MR \textbf{38} \#4213.

\bibitem{Blum2}
M. Blum, \textit{On effective procedures for sppeding up algorithms},
J. Assoc. Comput. Mach. \textbf{18} (1971), 290---305.

\end{thebibliography}
\end{document}
